---
title: "MGMT264B - Problem Set 1 - Due 1/21/22"
author: "Artin 705656472, Alex 605653488, Jason 205653819, Jorge 205653819"
date: "1/11/2022"
output: 
  html_document:
    code_folding: hide
    toc: TRUE
    toc_float: TRUE
---

## Instructions

This problem set is due by the start of class Friday, January 21 (1:00pm Section 1, 7:10pm Section 2).

You may work in groups of up to 4 people. Please put every team member's UCLA ID number in the header above, inside the quotes next to "author". Please do not include names in this document, to ensure blind grading.

You will need to submit **TWO** files:

1.  this .Rmd file, and

2.  the knitted HTML file.

Each group should submit only **ONE** version of each file (that is, only one group member should submit). To knit the file, first make sure all of the code runs from scratch. That is, restart R so that you have a clear environment and only standard packages loaded, and run all the code in this document in order. Make sure there are no `install.packages()` functions included, as they will cause a failure to knit (and you shouldn't need any to complete this problem set anyways). Then click the "Knit" button, or "Knit to HTML" from the Knit dropdown menu. A new .html file with this same file name will be created in the same folder.

Please do not exclude any code chunks from the knitted documents (i.e., do not use the `eval`, `include`, or `echo` options mentioned in Week 1 appendices). We've hidden the code by default.

The problem set is prepopulated with code chunks. Above each code chunk is a small header that describes exactly what output you need to report in your submitted files. Some questions just need code, some questions just need a written response, and some questions need both. If code is needed, there is already a code chunk. If a written response is needed, there is text that reads "enter your answer here".

## Preparation

As part of this assignment, you will construct a hedonic pricing model for diamonds, similar to how we constructed a hedonic pricing model in class for houses. Recall that upon running the model in class, we found b~0~ = 611896 and b~1~ = 531. This implies that if one house is 1 square foot larger than another, we expect the market to value the first house \$531 more. And we expect a house with a size of 0 square feet to be valued at \$611,896. (This latter estimate is well outside the range of the data, as we don't see any houses that are 0 square feet, so its substantive interpretation is suspect.)

To start:

1.  Load the `tidyverse` set of packages.

2.  Then load the `diamonds` dataset from the `ggplot2` package using the `data()` function. In particular, use `data(diamonds)`.

    -   Rather than loading a dataset from an external .csv or .xlsx file, this will load it from the `ggplot2` package. The `ggplot2` package was loaded when you loaded the `tidyverse` packages.

    -   Notice that the `data()` function has the *effect* of adding the `diamonds` data frame to your R environment. You do not need to assign the output of the `data()` function to a data frame like we did with `homes` and `read_csv()`.

3.  We'll focus on three variables from the `diamonds` dataset:

    1.  `price` (in dollars),

    2.  `carat` (representing the size of the diamond), and

    3.  `cut` (representing the quality of the cut, which influences its ability to reflect light and sparkle.)

    Use the `table()` function and the `cut` variable from the `diamonds` dataset (i.e., `table(diamonds$cut)` to count the number of each type of cut. You should see that there are 21,551 "Ideal" cut diamonds in the dataset.

4.  Next, create a new data frame called `ideal` consisting of only and all ideal diamonds from the `diamonds` data frame. You can do this using the `filter()` function as shown below:

    `ideal <- filter(diamonds, cut == "Ideal")`

5.  Verify that:

    1.  `ideal` has 21,551 observations and 10 variables in it,

    2.  `mean(ideal$carat)` gives you `0.702837`, and

    3.  `mean(ideal$price)` gives you `3457.542`.

    If you do not get those numbers (making an allowance for rounding), ***something has gone wrong**.* Make sure to fix it before moving on to the rest of the problem set. If you get really stuck, I can help you get to this point.

```{r preparation}

library(tidyverse)
library(ggplot2)
data(diamonds)

dim(diamonds)
head(diamonds)

table(diamonds$cut)

ideal <- filter(diamonds, cut == "Ideal")

mean(ideal$carat)
mean(ideal$price)


```

## Question 1

The `log()` function takes the natural logarithm (i.e., logarithm with base e \~= 2.72) of a number or vector. If e^z^ = x, then log(x) = z (this refers to the mathematical constant e, not e as in error or residual). This function has the effect of compressing large values. Consider the relationship between x and log(x) as shown in the plot generated by the code below:

```{r}
x <- 1:1000
logx <- log(x)
qplot(x, logx)
```

Here are a few properties of logs that are useful to keep in mind.

```{r}
log(1) # log(1) == 0

log(2 * 3)
log(2) + log(3) # log(z * w) == log(z) + log(w)

log(2 ^ 3)
3 * log(2) # log(z ^ w) == w * log(z)

exp(log(5.4)) # exp(log(x)) == x, where exp() takes e (~= 2.72) and raises it to the value of the function's argument
```

Notice that the `exp()` function (for "***exp***onentiate") effectively "un-logs" a quantity.

Now, create two new variables in the `ideal` dataset:

1.  `logprice`, the natural logarithm of `price`, and

2.  `logcarat`, the natural logarithm of `carat`.

One way to do this for price would be to use the following code: `ideal$logprice <- log(ideal$price)`.

### 1a

Using the `qplot()` function twice, display two histograms of the `ideal` data frame.

1.  The first histogram should have `price` on the x-axis.

2.  The second histogram should have `logprice` on the x-axis.

Notice how these two plots relate to the scatterplot above.

```{r q1a}

ideal$logprice <- log(ideal$price)

qplot(ideal$price)
qplot(ideal$logprice)
```

### 1b

Using the `qplot()` function three times, display three scatterplots of the `ideal` data frame.

1.  The first plot should have `carat` on the x-axis and `price` on the y-axis.

2.  The second should have `carat` on the x-axis and `logprice` on the y-axis.

3.  The third should have `logcarat` on the x-axis and `logprice` on the y-axis.

Of these three plots, consider which of these relationships appears to be most suitable to be modeled via a **linear** relationship. That is, if you were to eyeball the relationship between x and y, consider which one appears to lie along a line.

```{r q1b}

qplot(ideal$carat, ideal$price)
qplot(ideal$carat, ideal$logprice)

ideal$logcarat <- log(ideal$carat)
qplot(ideal$logcarat,ideal$logprice) #The scatter plot that looks to have a more linear relationship is the log of carat and log of price scatter plot.



```

## Question 2

### 2a

Use the `lm()` function to estimate a linear model predicting `logprice` from `logcarat` for ideal diamonds. Name the output of the model `m1`. This question should be answerable with a single line of code.

-   Note: In class, we took several different approaches to calculating the intercept and slope: the `lm()` function, the formulas for b~0~ and b~1~, thinking about "votes" and "weights", and simulation by testing random lines through mean(x) and mean(y). Each approach led to the same coefficients; they just enable us to understand the solution from different angles. When we build models, we typically just use an approach like `lm()`.

```{r q2a}

m1 <- lm(logprice ~ logcarat, ideal)

mean(ideal$logcarat)
mean(ideal$logprice)
mean(ideal$price)
mean(ideal$carat)


str(m1)
summary(m1)

```

### 2b

Report and interpret the intercept and slope of `m1`. *Make sure to keep in mind what x and y are and how they have been transformed!*

```{r q2b}

coef(m1)

model_coefs <- coef(m1) 
model_coefs

exp(model_coefs[1])
exp(model_coefs[2])
```

#### Answer 2b

Intercept = 8.523274 --> Any diamond will cost an minimum of exp(8.523274) = \$5,030.6

logCarat = 1.707240 --> Depending on the carat size of the diamond the price will increase by exp(1.707240) = \$5.51 per carat

### 2c

You created `logprice` by taking the `log()` of `price`. Recall from above that you can "un-log" by using the `exp()` function. So `exp(logprice)` should get you back to `price` in dollars.

Convert the intercept into (raw) dollars and interpret what it means. Remember what your x variable is and that log(1) = 0.

```{r q2c}

exp(model_coefs[1])
exp(model_coefs[2])


#(p1 <- qplot(x = ideal$logcarat, y = ideal$logprice,
#             xlab = "Log(Carat)", ylab = "Log(Price)"))
#(p2 <- p1 + 
#    geom_abline(intercept = model_coefs[1], 
#                slope = model_coefs[2], 
#                color = "red"))

```

#### Answer 2c

Intercept = 8.523274 --> Any diamond will cost an minimum of exp(8.523274) = \$5,030.6 logCarat = 1.707240 --> Depending on the carat size of the diamond the price will increase by exp(1.707240) = \$5.51 per carat

### 2d

Using the `predict()` function, make two sets of predictions from `m1` for when `carat` = 0.5, 1, and 1.5. (Note that you'll need to calculate the corresponding values for `logcarat`):

1.  First, report your prediction in log(dollars).

2.  Second, report your prediction in raw (not log) dollars.

```{r q2d}

new_diamond <- data.frame(logcarat = c(log(0.5), log(1), log(1.5)))
new_diamond
pred123k <- predict(m1, new_diamond)

pred123k
exp(pred123k)
exp(new_diamond)
new_diamond



```

### 2e

Look at the difference between your predictions for carat = 0.5 and carat = 1, and the difference between your predictions for carat = 1 and carat = 1.5. Given that we use a linear prediction rule to predict Y from X, and 1-0.5 = 1.5-1, why do neither our log(dollar) predictions nor our dollar predictions linearly increase with carats? Think carefully about how Y and X are scaled. We'll discuss additional nuance in interpreting these kinds of models in more detail in Week 4.

#### Answer 2e

\[Insert Answer\]

## Question 3

### 3a

Write a new version of the `model_score` function from Week 2 code. Call this new version `model_score_int`. `model_score_int` should take three arguments:

1.  a guess for the *intercept* (rather than a guess for the slope, as was used in `model_score`),

2.  a vector of x's, and

3.  a vector of y's.

The function should use the guess for the intercept to calculate the slope that passes through the point (mean(x), mean(y)). Remember that if you given two points (for example, the point of means and the point represented by the intercept!) you can calculate the slope as (Y~2~-Y~1~) / (X~2~-X~1~).

Using the line defined by the intercept passed to the function and the calculated slope as your prediction rule, `model_score_int` should calculate the sum of squared errors for the data given by x and y. (This chunk of code won't generate any output.)

```{r q3a}

model_score_int <- function(b0, x, y) {
  b1 <- (mean(y) - b0 ) / mean(x)
  yhat <- b0 + b1 * x
  e <- y - yhat
  sum(e^2)
}

```

### 3b

Use `model_score_int` to assess SSE for the `ideal` data, predicting `logprice` from `logcarat`, given b0 = 8. What is SSE for that model?

```{r q3b}


model_score_int(b0 = 8, x = ideal$logcarat, y = ideal$logprice)
sse <- map_dbl(8, model_score_int, x = ideal$logcarat, y = ideal$logprice)

sse
```

### 3c

Generate 1000 guesses for the intercept, drawn at random from a uniform distribution ranging from 6 to 10. Display the first 6 guesses.

```{r q3c}

n_guess <- 1000
b0_guess <- runif(n = n_guess, min = 6, max = 10)
head(b0_guess)

```

### 3d

Calculate a set of 1000 SSE using `map_dbl`, `model_score_int`, your guesses for the intercept, `ideal$logcarat` as x, and `ideal$logprice` as y. Display the first 6 values of SSE.scren

```{r q3d}

#model_score_int(b0 = b0_guess, x = ideal$logcarat, y = ideal$logprice)
sse <- map_dbl(b0_guess, model_score_int, x = ideal$logcarat, y = ideal$logprice)

head(sse)

```

### 3e

Plot SSE as a function of your b~0~ guesses.

```{r q3e}

qplot(b0_guess, sse)
which.min(sse)
sse[which.min(sse)]
b0_guess[which.min(sse)]


```

### 3f

Discuss how the plot in (3e) relates to the coefficients you reported in (2b).

#### Answer 3f

The plot validates our initial estimation for b0 (intercept) and the global minimum is equal to our estimation of 8.52 for b0. The regressions sum of squared errors are at its lowest at the global minimum, hence our lm b0 is optimized to it's maximum point.

## Question 4

### 4a

Use the `anova()` function to calculate SST, SSR, and SSE for `m1`.

```{r q4a}
anova(m1)


```

### 4b

What is the value of SSR?

#### Answer 4b

The sum of squared residuals is 19,809.7.

### 4c

What is the value of SSE?

#### Answer 4c

The sum of squared errors is 1,410.7.

### 4d

What is the value of SST?

#### Answer 4d

Total sum of squares is equal to SSR + SSE which is 21,220.4

### 4e

What is R^2^? Confirm that the R^2^ you calculated from the numbers above matches the R^2^ from `summary(m1)`.

```{r}

summary(m1)
str(m1)



```

#### Answer 4e

R\^2 = SSR / SST = 1 - (SSE / SST) = 1 - (1,410.7/21,220.4); which equals 93.35% and matches our initial regression R\^2.

## Question 5

### 5a

Make a plot of the residuals of `m1` on the y-axis and `logcarat` on the x-axis.

```{r}

mean(ideal$logcarat)
m2 <- lm(m1$residuals~logcarat, ideal)
m2
model_coefs2 <- coef(m2) 
model_coefs2

(p3 <- qplot(x = ideal$logcarat, y = m1$residuals,
             xlab = "Log(Carat)", ylab = "Residuals(M1)"))
(p4 <- p3 + 
    geom_abline(intercept = model_coefs2[1], 
                slope = model_coefs2[2], 
                color = "red"))

```

### 5b

Describe (in words) where the best fit line predicting residuals from `logcarat` on the plot above would lie. Why would it be there? (You do not need to explicitly model this using `lm()`, but doing so should give you the same answer.)

#### Answer 5b

A horizontal line on Y = 0. The entire purpose of the best fit line would mean that residuals are equal to 0.

## Question 6

Make sure that you have read Chapters [2](https://moderndive.com/2-viz.html) and [3](https://moderndive.com/3-wrangling.html) in *ModernDive*. Once you have, describe in your own words what the code chunk below will do.

```{r}
diamonds %>%
  mutate(price_carat = price / carat) %>%
  group_by(cut) %>%
  summarize(m_price_carat = mean(price_carat))
```

#### Answer 6

Data extracted from Diamonds via pipe operator combines multiple operations into a single action. Mutate creates a new variable table price per carat then groups by cut, and finally it would provide the mean price/carat for the given cut.
